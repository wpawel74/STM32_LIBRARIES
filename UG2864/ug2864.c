/*
  GOFi2cOLED.h - SSD1306 OLED Driver Library
  2012 Copyright (c) GOF Electronics Co. Ltd.  All right reserved.
 
  Original Author: Limor Fried/Ladyada£¨Adafruit Industries£©
  Modified by: Jimbo.we(www.geekonfire.com)
  
  GeekOnFire invests time and resources providing this open source code, 
	please support GeekOnFire and open-source hardware by purchasing 
	products from GeekOnFire!
	
  This library is derived from Adafruit_GFX library, only for SSD1306 in I2C Mode.
  It is a free software; you can redistribute it and/or modify it 
  under the terms of BSD license, check license.txt for more information.
	All text above must be included in any redistribution.
*/
#include <stdlib.h>
#include <string.h>
#include "ug2864_ll.h"
#include "ug2864.h"

// a 5x7 font table
const unsigned char  BasicFont[] = {
	0x00, 0x00, 0x00, 0x00, 0x00,
	0x3E, 0x5B, 0x4F, 0x5B, 0x3E, 	
	0x3E, 0x6B, 0x4F, 0x6B, 0x3E, 	
	0x1C, 0x3E, 0x7C, 0x3E, 0x1C, 
	0x18, 0x3C, 0x7E, 0x3C, 0x18, 
	0x1C, 0x57, 0x7D, 0x57, 0x1C, 
	0x1C, 0x5E, 0x7F, 0x5E, 0x1C, 
	0x00, 0x18, 0x3C, 0x18, 0x00, 
	0xFF, 0xE7, 0xC3, 0xE7, 0xFF, 
	0x00, 0x18, 0x24, 0x18, 0x00, 
	0xFF, 0xE7, 0xDB, 0xE7, 0xFF, 
	0x30, 0x48, 0x3A, 0x06, 0x0E, 
	0x26, 0x29, 0x79, 0x29, 0x26, 
	0x40, 0x7F, 0x05, 0x05, 0x07, 
	0x40, 0x7F, 0x05, 0x25, 0x3F, 
	0x5A, 0x3C, 0xE7, 0x3C, 0x5A, 
	0x7F, 0x3E, 0x1C, 0x1C, 0x08, 
	0x08, 0x1C, 0x1C, 0x3E, 0x7F, 
	0x14, 0x22, 0x7F, 0x22, 0x14, 
	0x5F, 0x5F, 0x00, 0x5F, 0x5F, 
	0x06, 0x09, 0x7F, 0x01, 0x7F, 
	0x00, 0x66, 0x89, 0x95, 0x6A, 
	0x60, 0x60, 0x60, 0x60, 0x60, 
	0x94, 0xA2, 0xFF, 0xA2, 0x94, 
	0x08, 0x04, 0x7E, 0x04, 0x08, 
	0x10, 0x20, 0x7E, 0x20, 0x10, 
	0x08, 0x08, 0x2A, 0x1C, 0x08, 
	0x08, 0x1C, 0x2A, 0x08, 0x08, 
	0x1E, 0x10, 0x10, 0x10, 0x10, 
	0x0C, 0x1E, 0x0C, 0x1E, 0x0C, 
	0x30, 0x38, 0x3E, 0x38, 0x30, 
	0x06, 0x0E, 0x3E, 0x0E, 0x06, 
	0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x5F, 0x00, 0x00, 
	0x00, 0x07, 0x00, 0x07, 0x00, 
	0x14, 0x7F, 0x14, 0x7F, 0x14, 
	0x24, 0x2A, 0x7F, 0x2A, 0x12, 
	0x23, 0x13, 0x08, 0x64, 0x62, 
	0x36, 0x49, 0x56, 0x20, 0x50, 
	0x00, 0x08, 0x07, 0x03, 0x00, 
	0x00, 0x1C, 0x22, 0x41, 0x00, 
	0x00, 0x41, 0x22, 0x1C, 0x00, 
	0x2A, 0x1C, 0x7F, 0x1C, 0x2A, 
	0x08, 0x08, 0x3E, 0x08, 0x08, 
	0x00, 0x80, 0x70, 0x30, 0x00, 
	0x08, 0x08, 0x08, 0x08, 0x08, 
	0x00, 0x00, 0x60, 0x60, 0x00, 
	0x20, 0x10, 0x08, 0x04, 0x02, 
	0x3E, 0x51, 0x49, 0x45, 0x3E, 
	0x00, 0x42, 0x7F, 0x40, 0x00, 
	0x72, 0x49, 0x49, 0x49, 0x46, 
	0x21, 0x41, 0x49, 0x4D, 0x33, 
	0x18, 0x14, 0x12, 0x7F, 0x10, 
	0x27, 0x45, 0x45, 0x45, 0x39, 
	0x3C, 0x4A, 0x49, 0x49, 0x31, 
	0x41, 0x21, 0x11, 0x09, 0x07, 
	0x36, 0x49, 0x49, 0x49, 0x36, 
	0x46, 0x49, 0x49, 0x29, 0x1E, 
	0x00, 0x00, 0x14, 0x00, 0x00, 
	0x00, 0x40, 0x34, 0x00, 0x00, 
	0x00, 0x08, 0x14, 0x22, 0x41, 
	0x14, 0x14, 0x14, 0x14, 0x14, 
	0x00, 0x41, 0x22, 0x14, 0x08, 
	0x02, 0x01, 0x59, 0x09, 0x06, 
	0x3E, 0x41, 0x5D, 0x59, 0x4E, 
	0x7C, 0x12, 0x11, 0x12, 0x7C, 
	0x7F, 0x49, 0x49, 0x49, 0x36, 
	0x3E, 0x41, 0x41, 0x41, 0x22, 
	0x7F, 0x41, 0x41, 0x41, 0x3E, 
	0x7F, 0x49, 0x49, 0x49, 0x41, 
	0x7F, 0x09, 0x09, 0x09, 0x01, 
	0x3E, 0x41, 0x41, 0x51, 0x73, 
	0x7F, 0x08, 0x08, 0x08, 0x7F, 
	0x00, 0x41, 0x7F, 0x41, 0x00, 
	0x20, 0x40, 0x41, 0x3F, 0x01, 
	0x7F, 0x08, 0x14, 0x22, 0x41, 
	0x7F, 0x40, 0x40, 0x40, 0x40, 
	0x7F, 0x02, 0x1C, 0x02, 0x7F, 
	0x7F, 0x04, 0x08, 0x10, 0x7F, 
	0x3E, 0x41, 0x41, 0x41, 0x3E, 
	0x7F, 0x09, 0x09, 0x09, 0x06, 
	0x3E, 0x41, 0x51, 0x21, 0x5E, 
	0x7F, 0x09, 0x19, 0x29, 0x46, 
	0x26, 0x49, 0x49, 0x49, 0x32, 
	0x03, 0x01, 0x7F, 0x01, 0x03, 
	0x3F, 0x40, 0x40, 0x40, 0x3F, 
	0x1F, 0x20, 0x40, 0x20, 0x1F, 
	0x3F, 0x40, 0x38, 0x40, 0x3F, 
	0x63, 0x14, 0x08, 0x14, 0x63, 
	0x03, 0x04, 0x78, 0x04, 0x03, 
	0x61, 0x59, 0x49, 0x4D, 0x43, 
	0x00, 0x7F, 0x41, 0x41, 0x41, 
	0x02, 0x04, 0x08, 0x10, 0x20, 
	0x00, 0x41, 0x41, 0x41, 0x7F, 
	0x04, 0x02, 0x01, 0x02, 0x04, 
	0x40, 0x40, 0x40, 0x40, 0x40, 
	0x00, 0x03, 0x07, 0x08, 0x00, 
	0x20, 0x54, 0x54, 0x78, 0x40, 
	0x7F, 0x28, 0x44, 0x44, 0x38, 
	0x38, 0x44, 0x44, 0x44, 0x28, 
	0x38, 0x44, 0x44, 0x28, 0x7F, 
	0x38, 0x54, 0x54, 0x54, 0x18, 
	0x00, 0x08, 0x7E, 0x09, 0x02, 
	0x18, 0xA4, 0xA4, 0x9C, 0x78, 
	0x7F, 0x08, 0x04, 0x04, 0x78, 
	0x00, 0x44, 0x7D, 0x40, 0x00, 
	0x20, 0x40, 0x40, 0x3D, 0x00, 
	0x7F, 0x10, 0x28, 0x44, 0x00, 
	0x00, 0x41, 0x7F, 0x40, 0x00, 
	0x7C, 0x04, 0x78, 0x04, 0x78, 
	0x7C, 0x08, 0x04, 0x04, 0x78, 
	0x38, 0x44, 0x44, 0x44, 0x38, 
	0xFC, 0x18, 0x24, 0x24, 0x18, 
	0x18, 0x24, 0x24, 0x18, 0xFC, 
	0x7C, 0x08, 0x04, 0x04, 0x08, 
	0x48, 0x54, 0x54, 0x54, 0x24, 
	0x04, 0x04, 0x3F, 0x44, 0x24, 
	0x3C, 0x40, 0x40, 0x20, 0x7C, 
	0x1C, 0x20, 0x40, 0x20, 0x1C, 
	0x3C, 0x40, 0x30, 0x40, 0x3C, 
	0x44, 0x28, 0x10, 0x28, 0x44, 
	0x4C, 0x90, 0x90, 0x90, 0x7C, 
	0x44, 0x64, 0x54, 0x4C, 0x44, 
	0x00, 0x08, 0x36, 0x41, 0x00, 
	0x00, 0x00, 0x77, 0x00, 0x00, 
	0x00, 0x41, 0x36, 0x08, 0x00, 
	0x02, 0x01, 0x02, 0x04, 0x02, 
	0x3C, 0x26, 0x23, 0x26, 0x3C, 
	0x1E, 0xA1, 0xA1, 0x61, 0x12, 
	0x3A, 0x40, 0x40, 0x20, 0x7A, 
	0x38, 0x54, 0x54, 0x55, 0x59, 
	0x21, 0x55, 0x55, 0x79, 0x41, 
	0x21, 0x54, 0x54, 0x78, 0x41, 
	0x21, 0x55, 0x54, 0x78, 0x40, 
	0x20, 0x54, 0x55, 0x79, 0x40, 
	0x0C, 0x1E, 0x52, 0x72, 0x12, 
	0x39, 0x55, 0x55, 0x55, 0x59, 
	0x39, 0x54, 0x54, 0x54, 0x59, 
	0x39, 0x55, 0x54, 0x54, 0x58, 
	0x00, 0x00, 0x45, 0x7C, 0x41, 
	0x00, 0x02, 0x45, 0x7D, 0x42, 
	0x00, 0x01, 0x45, 0x7C, 0x40, 
	0xF0, 0x29, 0x24, 0x29, 0xF0, 
	0xF0, 0x28, 0x25, 0x28, 0xF0, 
	0x7C, 0x54, 0x55, 0x45, 0x00, 
	0x20, 0x54, 0x54, 0x7C, 0x54, 
	0x7C, 0x0A, 0x09, 0x7F, 0x49, 
	0x32, 0x49, 0x49, 0x49, 0x32, 
	0x32, 0x48, 0x48, 0x48, 0x32, 
	0x32, 0x4A, 0x48, 0x48, 0x30, 
	0x3A, 0x41, 0x41, 0x21, 0x7A, 
	0x3A, 0x42, 0x40, 0x20, 0x78, 
	0x00, 0x9D, 0xA0, 0xA0, 0x7D, 
	0x39, 0x44, 0x44, 0x44, 0x39, 
	0x3D, 0x40, 0x40, 0x40, 0x3D, 
	0x3C, 0x24, 0xFF, 0x24, 0x24, 
	0x48, 0x7E, 0x49, 0x43, 0x66, 
	0x2B, 0x2F, 0xFC, 0x2F, 0x2B, 
	0xFF, 0x09, 0x29, 0xF6, 0x20, 
	0xC0, 0x88, 0x7E, 0x09, 0x03, 
	0x20, 0x54, 0x54, 0x79, 0x41, 
	0x00, 0x00, 0x44, 0x7D, 0x41, 
	0x30, 0x48, 0x48, 0x4A, 0x32, 
	0x38, 0x40, 0x40, 0x22, 0x7A, 
	0x00, 0x7A, 0x0A, 0x0A, 0x72, 
	0x7D, 0x0D, 0x19, 0x31, 0x7D, 
	0x26, 0x29, 0x29, 0x2F, 0x28, 
	0x26, 0x29, 0x29, 0x29, 0x26, 
	0x30, 0x48, 0x4D, 0x40, 0x20, 
	0x38, 0x08, 0x08, 0x08, 0x08, 
	0x08, 0x08, 0x08, 0x08, 0x38, 
	0x2F, 0x10, 0xC8, 0xAC, 0xBA, 
	0x2F, 0x10, 0x28, 0x34, 0xFA, 
	0x00, 0x00, 0x7B, 0x00, 0x00, 
	0x08, 0x14, 0x2A, 0x14, 0x22, 
	0x22, 0x14, 0x2A, 0x14, 0x08, 
	0xAA, 0x00, 0x55, 0x00, 0xAA, 
	0xAA, 0x55, 0xAA, 0x55, 0xAA, 
	0x00, 0x00, 0x00, 0xFF, 0x00, 
	0x10, 0x10, 0x10, 0xFF, 0x00, 
	0x14, 0x14, 0x14, 0xFF, 0x00, 
	0x10, 0x10, 0xFF, 0x00, 0xFF, 
	0x10, 0x10, 0xF0, 0x10, 0xF0, 
	0x14, 0x14, 0x14, 0xFC, 0x00, 
	0x14, 0x14, 0xF7, 0x00, 0xFF, 
	0x00, 0x00, 0xFF, 0x00, 0xFF, 
	0x14, 0x14, 0xF4, 0x04, 0xFC, 
	0x14, 0x14, 0x17, 0x10, 0x1F, 
	0x10, 0x10, 0x1F, 0x10, 0x1F, 
	0x14, 0x14, 0x14, 0x1F, 0x00, 
	0x10, 0x10, 0x10, 0xF0, 0x00, 
	0x00, 0x00, 0x00, 0x1F, 0x10, 
	0x10, 0x10, 0x10, 0x1F, 0x10, 
	0x10, 0x10, 0x10, 0xF0, 0x10, 
	0x00, 0x00, 0x00, 0xFF, 0x10, 
	0x10, 0x10, 0x10, 0x10, 0x10, 
	0x10, 0x10, 0x10, 0xFF, 0x10, 
	0x00, 0x00, 0x00, 0xFF, 0x14, 
	0x00, 0x00, 0xFF, 0x00, 0xFF, 
	0x00, 0x00, 0x1F, 0x10, 0x17, 
	0x00, 0x00, 0xFC, 0x04, 0xF4, 
	0x14, 0x14, 0x17, 0x10, 0x17, 
	0x14, 0x14, 0xF4, 0x04, 0xF4, 
	0x00, 0x00, 0xFF, 0x00, 0xF7, 
	0x14, 0x14, 0x14, 0x14, 0x14, 
	0x14, 0x14, 0xF7, 0x00, 0xF7, 
	0x14, 0x14, 0x14, 0x17, 0x14, 
	0x10, 0x10, 0x1F, 0x10, 0x1F, 
	0x14, 0x14, 0x14, 0xF4, 0x14, 
	0x10, 0x10, 0xF0, 0x10, 0xF0, 
	0x00, 0x00, 0x1F, 0x10, 0x1F, 
	0x00, 0x00, 0x00, 0x1F, 0x14, 
	0x00, 0x00, 0x00, 0xFC, 0x14, 
	0x00, 0x00, 0xF0, 0x10, 0xF0, 
	0x10, 0x10, 0xFF, 0x10, 0xFF, 
	0x14, 0x14, 0x14, 0xFF, 0x14, 
	0x10, 0x10, 0x10, 0x1F, 0x00, 
	0x00, 0x00, 0x00, 0xF0, 0x10, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xFF, 0xFF, 
	0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 
	0x38, 0x44, 0x44, 0x38, 0x44, 
	0x7C, 0x2A, 0x2A, 0x3E, 0x14, 
	0x7E, 0x02, 0x02, 0x06, 0x06, 
	0x02, 0x7E, 0x02, 0x7E, 0x02, 
	0x63, 0x55, 0x49, 0x41, 0x63, 
	0x38, 0x44, 0x44, 0x3C, 0x04, 
	0x40, 0x7E, 0x20, 0x1E, 0x20, 
	0x06, 0x02, 0x7E, 0x02, 0x02, 
	0x99, 0xA5, 0xE7, 0xA5, 0x99, 
	0x1C, 0x2A, 0x49, 0x2A, 0x1C, 
	0x4C, 0x72, 0x01, 0x72, 0x4C, 
	0x30, 0x4A, 0x4D, 0x4D, 0x30, 
	0x30, 0x48, 0x78, 0x48, 0x30, 
	0xBC, 0x62, 0x5A, 0x46, 0x3D, 
	0x3E, 0x49, 0x49, 0x49, 0x00, 
	0x7E, 0x01, 0x01, 0x01, 0x7E, 
	0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 
	0x44, 0x44, 0x5F, 0x44, 0x44, 
	0x40, 0x51, 0x4A, 0x44, 0x40, 
	0x40, 0x44, 0x4A, 0x51, 0x40, 
	0x00, 0x00, 0xFF, 0x01, 0x03, 
	0xE0, 0x80, 0xFF, 0x00, 0x00, 
	0x08, 0x08, 0x6B, 0x6B, 0x08,
	0x36, 0x12, 0x36, 0x24, 0x36, 
	0x06, 0x0F, 0x09, 0x0F, 0x06, 
	0x00, 0x00, 0x18, 0x18, 0x00, 
	0x00, 0x00, 0x10, 0x10, 0x00, 
	0x30, 0x40, 0xFF, 0x01, 0x01, 
	0x00, 0x1F, 0x01, 0x01, 0x1E, 
	0x00, 0x19, 0x1D, 0x17, 0x12, 
	0x00, 0x3C, 0x3C, 0x3C, 0x3C, 
	0x00, 0x00, 0x00, 0x00, 0x00, 
};

//init GOF logo in buffer£¨this buffer map to the GDDRAM of SSD1306£©
static char buffer[128 * 64 / 8] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xF8,
	0xF8, 0xF0, 0xF0, 0xE0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0, 0xF0, 0xF8, 0x78, 0x78, 0xF8, 0xF0, 0xE0, 0xC0, 0x00, 0xC0,
	0xF0, 0xF0, 0xF0, 0x78, 0x78, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0x70, 0x70,
	0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
	0xC0, 0xE0, 0xE0, 0xF0, 0xF0, 0x78, 0x3C, 0xBC, 0xDE, 0xEF, 0xF7, 0xF0, 0xF8, 0x7C, 0x7E, 0xBF,
	0xDF, 0xFF, 0xEF, 0xFF, 0xF7, 0xF8, 0xFC, 0xF0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x38, 0x38, 0xFB, 0xFB, 0xFB, 0xFB, 0x00, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x1E, 0x1C,
	0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0x82, 0x8F,
	0x9F, 0x3F, 0x3F, 0x7F, 0x70, 0x66, 0xDF, 0x3F, 0x7F, 0xFF, 0x03, 0x01, 0x00, 0x1E, 0x3F, 0x7F,
	0xFF, 0xFF, 0x3F, 0x3F, 0x1F, 0x1F, 0x0F, 0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07, 0x07, 0x00, 0x01,
	0x07, 0x07, 0x0F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x01, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
	0x03, 0x07, 0x0F, 0x1F, 0x3E, 0x7E, 0x7E, 0xFE, 0xFE, 0x0E, 0x64, 0x78, 0x18, 0x1C, 0x1C, 0x1C,
	0x0C, 0x0C, 0x0C, 0x0E, 0x0E, 0x0E, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xFE, 0x12, 0x10, 0x38, 0x82, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x68,
	0x08, 0xB0, 0x20, 0x00, 0xF0, 0x90, 0x08, 0x18, 0x90, 0x00, 0x08, 0x08, 0xFE, 0x08, 0x88, 0x00,
	0x08, 0x08, 0xF8, 0x10, 0x08, 0x10, 0x00, 0xF0, 0x10, 0x08, 0x90, 0xF0, 0x00, 0x08, 0xF8, 0x08,
	0x08, 0xF0, 0x00, 0x00, 0x08, 0x0A, 0xFB, 0x00, 0x00, 0x00, 0xF0, 0x90, 0x08, 0x18, 0x80, 0x00,
	0x00, 0xB0, 0x68, 0x48, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00,
	0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,
	0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00,
	0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xF0, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x00, 0xE0, 0x20, 0x20, 0xC0, 0x00, 0x00, 0xC0, 0xA0,
	0xA0, 0xC0, 0x00, 0x00, 0xE0, 0x20, 0x20, 0xE0, 0x00, 0x00, 0x00, 0x30, 0x48, 0x48, 0x98, 0x00,
	0x00, 0xE0, 0x20, 0x20, 0xE0, 0x00, 0x00, 0xE0, 0x00, 0x00, 0xE0, 0x00, 0x00, 0xE0, 0x20, 0x20,
	0x00, 0xC0, 0x20, 0x20, 0x20, 0x00, 0xC0, 0xA0, 0xA0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xF0, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x00, 0xE0, 0x20, 0x20, 0xC0, 0x00, 0x00, 0xC0, 0xA0,
	0xA0, 0xC0, 0x00, 0x00, 0xE0, 0x20, 0x20, 0xE0, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x60, 0x80,
	0x80, 0x60, 0x18, 0xF8, 0x00, 0xE8, 0x00, 0x00, 0xE0, 0x20, 0x20, 0xE0, 0x00, 0x00, 0xC0, 0x20,
	0x20, 0xF8, 0x00, 0x00, 0xC0, 0xA0, 0xA0, 0xC0, 0x00, 0x00, 0xC0, 0x20, 0x20, 0xF8, 0x00, 0x00,
	0x00, 0x01, 0x02, 0x02, 0x02, 0x01, 0x00, 0x00, 0x0F, 0x02, 0x02, 0x01, 0x00, 0x00, 0x01, 0x02,
	0x02, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x02, 0x02, 0x01, 0x00,
	0x00, 0x03, 0x02, 0x02, 0x03, 0x00, 0x00, 0x03, 0x02, 0x02, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
	0x00, 0x01, 0x02, 0x02, 0x02, 0x00, 0x01, 0x02, 0x02, 0x02, 0x00, 0x08, 0x06, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x02, 0x02, 0x02, 0x01, 0x00, 0x00, 0x0F, 0x02, 0x02, 0x01, 0x00, 0x00, 0x01, 0x02,
	0x02, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
	0x03, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0x02,
	0x02, 0x03, 0x00, 0x00, 0x01, 0x02, 0x02, 0x02, 0x00, 0x00, 0x01, 0x02, 0x02, 0x03, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

#define pgm_read_byte(ptr)				*(ptr)

static uint8_t  WIDTH, HEIGHT;   // this is the 'raw' display w/h - never changes
static uint8_t  _width, _height; // dependent on rotation
static uint8_t  cursor_x, cursor_y;
static uint8_t  textcolor, textbgcolor;
static uint8_t  textsize;
static uint8_t  rotation;
static BOOLEAN  wrap; // If set, 'wrap' text at right edge of display


#define UG2864_WIDTH 		                  128	//128 Pixels
#define UG2864_HEIGHT 		                  64	//64  Pixels

#define UG2864_Command_Mode		              0x80
#define UG2864_Data_Mode		              0x40

//Fundamental Command (more than one bytes command pleaserefer to SSD1306 datasheet for details)
#define Set_Contrast_Cmd                      0x81     //Double byte command to select 1 out of 256 contrast steps.Default(RESET = 0x7F)
#define Entire_Display_On_Resume_Cmd          0xA4     //Resume to RAM content display(RESET), Output follows RAM content
#define Entire_Display_On_Cmd                 0xA5     //Entire display ON, Output ignores RAM content
#define UG2864_Normal_Display_Cmd	          0xA6     //Normal display (RESET)
#define UG2864_Inverse_Display_Cmd	          0xA7     //Inverse display
#define UG2864_Display_Off_Cmd	              0xAE     //sleep mode(RESET)
#define UG2864_Display_On_Cmd	              0xAF     //normal mode

//Scrolling Command (more than one bytes command pleaserefer to SSD1306 datasheet for details)
#define Right_Horizontal_Scroll_Cmd           0x26
#define Left_Horizontal_Scroll_Cmd            0x27
#define Vertical_Right_Horizontal_Scroll_Cmd  0x29
#define Vertical_Left_Horizontal_Scroll_Cmd   0x2A
#define Activate_Scroll_Cmd                   0x2F
#define Deactivate_Scroll_Cmd                 0x2E
#define Set_Vertical_Scroll_Area_Cmd          0xA3

//Addressing Setting Command (more than one bytes command pleaserefer to SSD1306 datasheet for details)
#define Set_Memory_Addressing_Mode_Cmd        0x20
#define HORIZONTAL_MODE			        0x00
#define VERTICAL_MODE			        0x01
#define PAGE_MODE			            0x02       //Default(reset)
#define Set_Column_Address_Cmd                0x21       //Setup column start and end address. This command is only for horizontal or vertical addressing mode.
#define Set_Page_Address_Cmd                  0x22       //Setup page start and end address. This command is only for horizontal or vertical addressing mode.

//Hardware Configuration (Panel resolution & layout related) Command (more than one bytes command please refer to SSD1306 datasheet for details)
#define Segment_Remap_Cmd                     0xA1       //column address 127 is mapped to SEG0
#define Segment_Normal_map_Cmd                0xA0       //Default. column address 0 is mapped to SEG0(RESET)
#define Set_Multiplex_Ratio_Cmd               0xA8       //Set MUX ratio to N+1 MUX
#define COM_Output_Normal_Scan_Cmd            0xC0       //Normal mode (RESET). Scan from COM0 to COM[N ¨C1]
#define COM_Output_Remap_Scan_Cmd             0xC8       //Remapped mode. Scan from COM[N-1] to COM0
#define Set_Display_Offset_Cmd                0xD3       //Set vertical shift by COM from 0d~63d. The value is reset to 00h after RESET.
#define Set_COM_Pins_Hardware_Config_Cmd      0xDA

//Timing & Driving Scheme Setting Command (more than one bytes command pleaserefer to SSD1some more than one bytes command please 306 datasheet for details)
#define Set_Display_Clock_Divide_Ratio_Cmd    0xD5
#define Set_Precharge_Period_Cmd              0xD9
#define Set_VCOMH_Deselect_Level_Cmd          0xDB
#define No_Operation_Cmd                      0xE3

#define Charge_Pump_Setting_Cmd      	      0x8D
#define Charge_Pump_Enable_Cmd	              0x14
#define Charge_Pump_Disable_Cmd               0x10     //default

#define Scroll_Left			          0x00
#define Scroll_Right			      0x01

#define Scroll_2Frames			      0x7
#define Scroll_3Frames			      0x4
#define Scroll_4Frames			      0x5
#define Scroll_5Frames			      0x0
#define Scroll_25Frames			      0x6
#define Scroll_64Frames			      0x1
#define Scroll_128Frames		      0x2
#define Scroll_256Frames		      0x3

#define Dummy_Byte_0x00               0x00
#define Dummy_Byte_0xFF               0xFF

#define swap(a, b)                    { uint8_t t = a; a = b; b = t; }
#define _BV(x)                        (1<<x)

static void UG2864_constructor(uint8_t w, uint8_t h) {
	_width = WIDTH = w;
	_height = HEIGHT = h;

	rotation = 0;
	cursor_y = cursor_x = 0;
	textsize = 1;
	textcolor = textbgcolor = WHITE;
	wrap = TRUE;
}

void UG2864_init(void){

	UG2864_LL_SPIInit();

	UG2864_CS_INIT;
	UG2864_DC_INIT;
	UG2864_BACKLIGHT_INIT;
	UG2864_RST_INIT;

	// enable backlight for OLED
	UG2864_BACKLIGHT_HIGH;
	UG2864_RST_HIGH;

	//delay(5);	//wait for OLED hardware init
	UG2864_constructor(128, 64);
	UG2864_LL_SPITx(UG2864_Display_Off_Cmd);    /*display off*/
	UG2864_LL_SPITx(Set_Multiplex_Ratio_Cmd);    /*multiplex ratio*/
	UG2864_LL_SPITx(0x3F);   //OK /*duty = 1/64*/

	UG2864_LL_SPITx(Set_Display_Offset_Cmd);    /*set display offset*/
	UG2864_LL_SPITx(0x00);	//OK

	UG2864_LL_SPITx(0xB0); 			//set page address
	UG2864_LL_SPITx(0x00); 	//set column lower address
	UG2864_LL_SPITx(0x10); 	//set column higher address

	UG2864_setHorizontalMode();   //OK     /*set Page Addressing Mode*/

	UG2864_LL_SPITx(0x21);    /* */
	UG2864_LL_SPITx(0x00);	//MISS OK
	UG2864_LL_SPITx(0x7f);	//MISS OK

	UG2864_LL_SPITx(0x22);    /* */
	UG2864_LL_SPITx(0x00);	//MISS OK
	UG2864_LL_SPITx(0x07);	//MISS OK

	UG2864_LL_SPITx(0x40);   //OK /*set display starconstructort line*/

	UG2864_LL_SPITx(Set_Contrast_Cmd);    /*contract control*/
	UG2864_LL_SPITx(0x5f);    //OK /*128*/

	UG2864_LL_SPITx(0x82);    /* brightness color area */
	UG2864_LL_SPITx(0x80);    //MISS OK

	UG2864_LL_SPITx(0x91);    /* lut */
	UG2864_LL_SPITx(0x3f);    //MISS OK
	UG2864_LL_SPITx(0x00);    //MISS OK
	UG2864_LL_SPITx(0x00);    //MISS OK
	UG2864_LL_SPITx(0x00);    //MISS OK

	UG2864_LL_SPITx(0x92);    /* bank color 1_16 */
	UG2864_LL_SPITx(0x00);    //MISS OK
	UG2864_LL_SPITx(0x00);    //MISS OK
	UG2864_LL_SPITx(0x00);    //MISS OK
	UG2864_LL_SPITx(0x00);    //MISS OK

	UG2864_LL_SPITx(0x93);    /* bank color 17_32 */
	UG2864_LL_SPITx(0x00);    //MISS OK
	UG2864_LL_SPITx(0x00);    //MISS OK
	UG2864_LL_SPITx(0x00);    //MISS OK
	UG2864_LL_SPITx(0x00);    //MISS OK

	UG2864_LL_SPITx(0xA0);    //MISS OK
	//UG2864_LL_SPITx(Segment_Remap_Cmd);    /*set segment remap*/

	UG2864_LL_SPITx(Entire_Display_On_Resume_Cmd); //MISS OK
	//UG2864_LL_SPITx(COM_Output_Remap_Scan_Cmd);  // ??  /*Com scan direction*/

	UG2864_LL_SPITx(UG2864_Normal_Display_Cmd);    //OK /* normal / reverse*/

	UG2864_LL_SPITx(Set_Display_Clock_Divide_Ratio_Cmd); //OK    /*set osc division*/
	UG2864_LL_SPITx(0xa0);

	UG2864_LL_SPITx(0xd3);    /* display offset mode */
	UG2864_LL_SPITx(0x00);	//MISS OK

	UG2864_LL_SPITx(0xd8);    /*set area color mode */
	UG2864_LL_SPITx(0x05);	//MISS OK

	UG2864_LL_SPITx(Set_Precharge_Period_Cmd);    /*set pre-charge period*/
	UG2864_LL_SPITx(0x25);	//OK

	UG2864_LL_SPITx(Set_COM_Pins_Hardware_Config_Cmd);    /*set COM pins*/
	UG2864_LL_SPITx(0x12);	//OK

	UG2864_LL_SPITx(Set_VCOMH_Deselect_Level_Cmd);    /*set vcomh*/
	UG2864_LL_SPITx(0x34);	//OK

	//UG2864_LL_SPITx(Deactivate_Scroll_Cmd);

	//UG2864_LL_SPITx(Charge_Pump_Setting_Cmd);    /*set charge pump enable*/
	//UG2864_LL_SPITx(Charge_Pump_Enable_Cmd);

	UG2864_LL_SPITx(UG2864_Display_On_Cmd);    /*display ON*/

	UG2864_LL_SPIFlush(buffer, sizeof(buffer));
}

// the most basic function, set a single pixel
void UG2864_drawPixel(uint8_t x, uint8_t y, uint8_t color) {
	if ((x < 0) || (x >= UG2864_width()) || (y < 0) || (y >= UG2864_height()))
		return;

	// check rotation, move pixel around if necessary
	switch (UG2864_getRotation()) {
	case 1:
		swap(x, y);
		x = WIDTH - x - 1;
		break;
	case 2:
		x = WIDTH - x - 1;
		y = HEIGHT - y - 1;
		break;
	case 3:
		swap(x, y);
		y = HEIGHT - y - 1;
		break;
	}
	// x is which column
	if (color == WHITE)
		buffer[x+ (y/8)*128] |= _BV((y%8));
	else
		buffer[x+ (y/8)*128] &= ~_BV((y%8));
}

void UG2864_setBrightness(unsigned char Brightness){
	UG2864_LL_SPITx(Set_Contrast_Cmd);
	UG2864_LL_SPITx(Brightness);
}

void UG2864_setHorizontalMode(void){
	UG2864_LL_SPITx(Set_Memory_Addressing_Mode_Cmd); 	//set addressing mode
	UG2864_LL_SPITx(HORIZONTAL_MODE); 			//set horizontal addressing mode
}

void UG2864_setVerticalMode(void){
	UG2864_LL_SPITx(Set_Memory_Addressing_Mode_Cmd); 	//set addressing mode
	UG2864_LL_SPITx(VERTICAL_MODE); 			//set horizontal addressing mode
}

void UG2864_setPageMode(void){
	UG2864_LL_SPITx(Set_Memory_Addressing_Mode_Cmd); 	//set addressing mode
	UG2864_LL_SPITx(PAGE_MODE); 			        //set page addressing mode
}

void UG2864_clearDisplay(void){
	memset(buffer, 0, (128*64/8));
}

void UG2864_clearArea(uint8_t x, uint8_t y, uint8_t w, uint8_t h){
	UG2864_fillRect(x, y, w, h, BLACK);
}

void UG2864_drawBitmap(uint8_t x, uint8_t y,
			      const uint8_t *bitmap, uint8_t w, uint8_t h,
			      uint8_t color) {
	uint8_t j;
	for (j=0; j<h; j++) {
		uint8_t i;
		for (i=0; i<w; i++ ) {
			if (pgm_read_byte(bitmap + i + (j/8)*w) & _BV(j%8)) {
				UG2864_drawPixel(x+i, y+j, color);
			}
		}
	}
}

// draw a character
void UG2864_drawChar(int8_t x, int8_t y, unsigned char c, int8_t color, int8_t bg, uint8_t size) {
	int8_t i;
	if((x >= _width)            || // Clip right
			(y >= _height)           || // Clip bottom
			((x + 5 * size - 1) < 0) || // Clip left
			((y + 8 * size - 1) < 0))   // Clip top
		return;

	for (i=0; i<6; i++ ) {
		uint8_t line;
		int8_t j;
		if (i == 5)
			line = 0x0;
		else
			line = pgm_read_byte(BasicFont+(c*5)+i);
		for (j = 0; j<8; j++) {
			if (line & 0x1) {
				if (size == 1) // default size
					UG2864_drawPixel(x+i, y+j, color);
				else {  // big size
					UG2864_fillRect(x+(i*size), y+(j*size), size, size, color);
				}
			} else if (bg != color) {
				if (size == 1) // default size
					UG2864_drawPixel(x+i, y+j, bg);
				else {  // big size
					UG2864_fillRect(x+i*size, y+j*size, size, size, bg);
				}
			}
			line >>= 1;
		}
	}
}

void UG2864_setTextSize(uint8_t s) {
	textsize = (s > 0) ? s : 1;
}

void UG2864_setCursor(uint8_t x, uint8_t y) {
	cursor_x = x;
	cursor_y = y;
}

void UG2864_setTextColor(uint8_t c, uint8_t b) {
	textcolor = c;
	textbgcolor = b;
}

void UG2864_setTextWrap(BOOLEAN w) {
	wrap = w;
}

// draw a rectangle
void UG2864_drawRect(uint8_t x, uint8_t y,
			    uint8_t w, uint8_t h, 
			    uint8_t color) {
	UG2864_drawFastHLine(x, y, w, color);
	UG2864_drawFastHLine(x, y+h-1, w, color);
	UG2864_drawFastVLine(x, y, h, color);
	UG2864_drawFastVLine(x+w-1, y, h, color);
}

void UG2864_fillRect(uint8_t x, uint8_t y, uint8_t w, uint8_t h,
			    uint8_t color) {
	uint8_t i;
	// stupidest version - update in subclasses if desired!
	for (i=x; i<x+w; i++) {
		UG2864_drawFastVLine(i, y, h, color);
	}
}

void UG2864_drawFastVLine(uint8_t x, uint8_t y,
				 uint8_t h, uint8_t color) {
	// stupidest version - update in subclasses if desired!
	UG2864_drawLine(x, y, x, y+h-1, color);
}

void UG2864_drawFastHLine(uint8_t x, uint8_t y,
				 uint8_t w, uint8_t color) {
	// stupidest version - update in subclasses if desired!
	UG2864_drawLine(x, y, x+w-1, y, color);
}

// bresenham's algorithm - thx wikpedia
void UG2864_drawLine(uint8_t x0, uint8_t y0,
			    uint8_t x1, uint8_t y1, 
			    uint8_t color) {
	int16_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
		swap(x0, y0);
		swap(x1, y1);
	}

	if (x0 > x1) {
		swap(x0, x1);
		swap(y0, y1);
	}

	int16_t dx, dy;
	dx = x1 - x0;
	dy = abs(y1 - y0);
	int16_t err = dx / 2;
	int16_t ystep;

	if (y0 < y1) {
		ystep = 1;
	} else {
		ystep = -1;
	}

	for (; x0<=x1; x0++) {
		if (steep) {
			UG2864_drawPixel(y0, x0, color);
		} else {
			UG2864_drawPixel(x0, y0, color);
		}
		err -= dy;
		if (err < 0) {
			y0 += ystep;
			err += dx;
		}
	}
}

// draw a rounded rectangle!
void UG2864_drawRoundRect(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint8_t r, uint8_t color) {
	// smarter version
	UG2864_drawFastHLine(x+r  , y    , w-2*r, color); // Top
	UG2864_drawFastHLine(x+r  , y+h-1, w-2*r, color); // Bottom
	UG2864_drawFastVLine(  x    , y+r  , h-2*r, color); // Left
	UG2864_drawFastVLine(  x+w-1, y+r  , h-2*r, color); // Right
	// draw four corners
	UG2864_drawCircleHelper(x+r    , y+r    , r, 1, color);
	UG2864_drawCircleHelper(x+w-r-1, y+r    , r, 2, color);
	UG2864_drawCircleHelper(x+w-r-1, y+h-r-1, r, 4, color);
	UG2864_drawCircleHelper(x+r    , y+h-r-1, r, 8, color);
}

// fill a rounded rectangle!
void UG2864_fillRoundRect(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint8_t r, uint8_t color) {
	// smarter version
	UG2864_fillRect(x+r, y, w-2*r, h, color);

	// draw four corners
	UG2864_fillCircleHelper(x+w-r-1, y+r, r, 1, h-2*r-1, color);
	UG2864_fillCircleHelper(x+r    , y+r, r, 2, h-2*r-1, color);
}


// draw a triangle!
void UG2864_drawTriangle(uint8_t x0, uint8_t y0,
				uint8_t x1, uint8_t y1, 
				uint8_t x2, uint8_t y2, uint8_t color) {
	UG2864_drawLine(x0, y0, x1, y1, color);
	UG2864_drawLine(x1, y1, x2, y2, color);
	UG2864_drawLine(x2, y2, x0, y0, color);
}

// fill a triangle!
void UG2864_fillTriangle (uint8_t x0, uint8_t y0,
				uint8_t x1, uint8_t y1, 
				uint8_t x2, uint8_t y2, uint8_t color) {

	int16_t a, b, y, last;

	// Sort coordinates by Y order (y2 >= y1 >= y0)
	if (y0 > y1) {
		swap(y0, y1); swap(x0, x1);
	}
	if (y1 > y2) {
		swap(y2, y1); swap(x2, x1);
	}
	if (y0 > y1) {
		swap(y0, y1); swap(x0, x1);
	}

	if(y0 == y2) { // Handle awkward all-on-same-line case as its own thing
		a = b = x0;
		if(x1 < a)      a = x1;
		else if(x1 > b) b = x1;
		if(x2 < a)      a = x2;
		else if(x2 > b) b = x2;
		UG2864_drawFastHLine(a, y0, b-a+1, color);
		return;
	}

	int16_t
	dx01 = x1 - x0,
	dy01 = y1 - y0,
	dx02 = x2 - x0,
	dy02 = y2 - y0,
	dx12 = x2 - x1,
	dy12 = y2 - y1,
	sa   = 0,
	sb   = 0;

	// For upper part of triangle, find scanline crossings for segments
	// 0-1 and 0-2.  If y1=y2 (flat-bottomed triangle), the scanline y1
	// is included here (and second loop will be skipped, avoiding a /0
	// error there), otherwise scanline y1 is skipped here and handled
	// in the second loop...which also avoids a /0 error here if y0=y1
	// (flat-topped triangle).
	if(y1 == y2) last = y1;   // Include y1 scanline
	else         last = y1-1; // Skip it

	for( y = y0; y <= last; y++ ) {
		a   = x0 + sa / dy01;
		b   = x0 + sb / dy02;
		sa += dx01;
		sb += dx02;
		/* longhand:
    	a = x0 + (x1 - x0) * (y - y0) / (y1 - y0);
    	b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
		 */
		if(a > b) swap(a,b);
		UG2864_drawFastHLine(a, y, b-a+1, color);
	}

	// For lower part of triangle, find scanline crossings for segments
	// 0-2 and 1-2.  This loop is skipped if y1=y2.
	sa = dx12 * (y - y1);
	sb = dx02 * (y - y0);
	for(; y<=y2; y++) {
		a   = x1 + sa / dy12;
		b   = x0 + sb / dy02;
		sa += dx12;
		sb += dx02;
		/* longhand:
		a = x1 + (x2 - x1) * (y - y1) / (y2 - y1);
		b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
		*/
		if(a > b) swap(a,b);
		UG2864_drawFastHLine(a, y, b-a+1, color);
	}
}

// draw a circle outline
void UG2864_drawCircle(uint8_t x0, uint8_t y0, uint8_t r,
			      uint8_t color) {
	int16_t f = 1 - r;
	int16_t ddF_x = 1;
	int16_t ddF_y = -2 * r;
	int16_t x = 0;
	int16_t y = r;

	UG2864_drawPixel(x0, y0+r, color);
	UG2864_drawPixel(x0, y0-r, color);
	UG2864_drawPixel(x0+r, y0, color);
	UG2864_drawPixel(x0-r, y0, color);

	while (x<y) {
		if (f >= 0) {
			y--;
			ddF_y += 2;
			f += ddF_y;
		}
		x++;
		ddF_x += 2;
		f += ddF_x;

		UG2864_drawPixel(x0 + x, y0 + y, color);
		UG2864_drawPixel(x0 - x, y0 + y, color);
		UG2864_drawPixel(x0 + x, y0 - y, color);
		UG2864_drawPixel(x0 - x, y0 - y, color);
		UG2864_drawPixel(x0 + y, y0 + x, color);
		UG2864_drawPixel(x0 - y, y0 + x, color);
		UG2864_drawPixel(x0 + y, y0 - x, color);
		UG2864_drawPixel(x0 - y, y0 - x, color);

	}
}

void UG2864_drawCircleHelper( uint8_t x0, uint8_t y0,
               uint8_t r, uint8_t cornername, uint8_t color) {
	int16_t f     = 1 - r;
	int16_t ddF_x = 1;
	int16_t ddF_y = -2 * r;
	int16_t x     = 0;
	int16_t y     = r;

	while (x<y) {
		if (f >= 0) {
			y--;
			ddF_y += 2;
			f    += ddF_y;
		}
		x++;
		ddF_x += 2;
		f     += ddF_x;
		if (cornername & 0x4) {
			UG2864_drawPixel(x0 + x, y0 + y, color);
			UG2864_drawPixel(x0 + y, y0 + x, color);
		}
		if (cornername & 0x2) {
			UG2864_drawPixel(x0 + x, y0 - y, color);
			UG2864_drawPixel(x0 + y, y0 - x, color);
		}
		if (cornername & 0x8) {
			UG2864_drawPixel(x0 - y, y0 + x, color);
			UG2864_drawPixel(x0 - x, y0 + y, color);
		}
		if (cornername & 0x1) {
			UG2864_drawPixel(x0 - y, y0 - x, color);
			UG2864_drawPixel(x0 - x, y0 - y, color);
		}
	}
}

void UG2864_fillCircle(uint8_t x0, uint8_t y0, uint8_t r,
			      uint8_t color) {
	UG2864_drawFastVLine(x0, y0-r, 2*r+1, color);
	UG2864_fillCircleHelper(x0, y0, r, 3, 0, color);
}

// used to do circles and roundrects!
void UG2864_fillCircleHelper(uint8_t x0, uint8_t y0, uint8_t r,
				    uint8_t cornername, int16_t delta, uint8_t color) {

	int16_t f     = 1 - r;
	int16_t ddF_x = 1;
	int16_t ddF_y = -2 * r;
	int16_t x     = 0;
	int16_t y     = r;

	while (x<y) {
		if (f >= 0) {
			y--;
			ddF_y += 2;
			f     += ddF_y;
		}
		x++;
		ddF_x += 2;
		f     += ddF_x;

		if (cornername & 0x1) {
			UG2864_drawFastVLine(x0+x, y0-y, 2*y+1+delta, color);
			UG2864_drawFastVLine(x0+y, y0-x, 2*x+1+delta, color);
		}
		if (cornername & 0x2) {
			UG2864_drawFastVLine(x0-x, y0-y, 2*y+1+delta, color);
			UG2864_drawFastVLine(x0-y, y0-x, 2*x+1+delta, color);
		}
	}
}

void UG2864_setHorizontalScrollProperties(BOOLEAN direction,unsigned char startPage, unsigned char endPage, unsigned char scrollSpeed){
/*
Use the following defines for 'direction' :

 Scroll_Left			
 Scroll_Right			

Use the following defines for 'scrollSpeed' :

 Scroll_2Frames		
 Scroll_3Frames
 Scroll_4Frames
 Scroll_5Frames	
 Scroll_25Frames
 Scroll_64Frames
 Scroll_128Frames
 Scroll_256Frames

*/

	if(Scroll_Right == direction){
		//Scroll Right
		UG2864_LL_SPITx(Right_Horizontal_Scroll_Cmd);
	} else {
		//Scroll Left
		UG2864_LL_SPITx(Left_Horizontal_Scroll_Cmd);
	}
	UG2864_LL_SPITx(Dummy_Byte_0x00);//Dummy byte
	UG2864_LL_SPITx(startPage);
	UG2864_LL_SPITx(scrollSpeed);
	UG2864_LL_SPITx(endPage);
	UG2864_LL_SPITx(Dummy_Byte_0x00);//Dummy byte
	UG2864_LL_SPITx(Dummy_Byte_0xFF);//Dummy byte
}

void UG2864_activateScroll(void){
	UG2864_LL_SPITx(Activate_Scroll_Cmd);
}

void UG2864_deactivateScroll(void){
	UG2864_LL_SPITx(Deactivate_Scroll_Cmd);
}

void UG2864_setNormalDisplay(void){
	UG2864_LL_SPITx(UG2864_Normal_Display_Cmd);
}

void UG2864_setInverseDisplay(void){
	UG2864_LL_SPITx(UG2864_Inverse_Display_Cmd);
}

void UG2864_setRotation(uint8_t x) {
	x %= 4;  // cant be higher than 3
	rotation = x;
	switch (x) {
	case 0:
	case 2:
		_width = WIDTH;
		_height = HEIGHT;
		break;
	case 1:
	case 3:
		_width = HEIGHT;
		_height = WIDTH;
		break;
	}
}

uint8_t UG2864_getRotation(void) {
	rotation %= 4;
	return rotation;
}

// return the size of the display which depends on the rotation!
uint8_t UG2864_width(void) {
	return _width;
}
 
uint8_t UG2864_height(void) {
	return _height;
}

#if ARDUINO >= 100
size_t UG2864_write(uint8_t c) {
#else
void UG2864_write(uint8_t c) {
#endif
	if (c == '\n') {
		cursor_y += textsize*8;
		cursor_x = 0;
	} else if (c == '\r') {
		// skip em
	} else {
		UG2864_drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize);
		cursor_x += textsize*6;
		if (wrap && (cursor_x > (_width - textsize*6))) {
			cursor_y += textsize*8;
			cursor_x = 0;
		}
	}
/*    if(C < 32 || C > 127) //Ignore non-printable ASCII characters. This can be modified for multilingual font.
    {
    C=' '; //Space
    }	
    unsigned char i=0;
    for(i=0;i<8;i++)
    {
       //read bytes from code memory
       sendData(pgm_read_byte(&BasicFont[C-32][i])); //font array starts at 0, ASCII starts at 32. Hence the translation
    }

*/

#if ARDUINO >= 100
  return 1;
#endif
}

//GOFi2cOLED GOFi2cOLED;  // Preinstantiate Objects

